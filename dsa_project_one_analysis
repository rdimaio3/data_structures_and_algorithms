Enclosed below is the pseudocode that can be used to fulfill the needs of ABCU’s Computer Science courses and scheduling, as requested. We were tasked with coming up with pseudocode to take data from a CSV and enter information for the various CS courses available, including course number, course name, and all prerequisites. We need to be able to store this data, print out all of the courses sorted by course number, and print out all of the information for any specific course number. This can be accomplished several different ways, including storing the data in a vector, hashtable, or binary search tree, as shown below. 
There are various advantages and disadvantages to each data structure. The most simple approach I believe would be to use a vector. It is the most simple data structure of the three we have used, and is easy to sort and iterate through. A vector can also be dynamically resized when new elements are added to it. Inserting n courses uses a runtime complexity of O(n). The parser enters each element of the Course struct into a single Course object for each line of the CSV. All of these commands and entries are done in constant time, and since we drop the constants of each operation, it is run in n time. Search and deletion in a vector is also performed in O(n) time.
A hashtable offers the benefit of encryption, which I don’t think is applicable in this situation. The data structures in this current version don’t hold any personal data from the students, only the information about the various courses, which would seem to be publicly available and not sensitive information. Hashtables also utilize O(n) runtimes for insertion, search, and deletion. A disadvantage of them is that by their nature they are not sortable due to using keys and buckets to find each element. In order to sort the hashtable for printing the courses in order, one way to do it, as the pseudocode shows, is to sort the elements into a vector, which obviously uses up more space than just starting with a vector on its own.
A binary search tree has a worse runtime for insertion and deletion, at O(n log n) because it has to first search through the tree O(log n) to find where to put the new data, and then insert it at O(n). The same goes for deletion. Where the BST shines is for searching. Assuming the tree is balanced, searching can be done in O(log n) time. If the tree is not balanced, however, we’re back to the usual O(n) time in a worst case scenario. Printing the schedule, which uses the recursive inOrder function, uses O(n) time.
Based on these findings, I believe the hashtable is the least suitable data structure for this given application. Its main benefit of encryption does not apply to this situation. A vector is simple and straightforward but gets the job done in a modestly efficient way. I believe the best data structure for this case would be a binary search tree. The disadvantage of this data structure is that inserting and deleting nodes takes longer than the others O(n log n), however insertion and deletion will have to be performed very infrequently. Many of the courses will only have to be inserted once and may never change, and those that do change or have to be added/deleted will be few and far between. The operation of printing in order, or searching for a printing a course, will be utilized much more frequently. Provided the tree is balanced, this will offer a better runtime complexity of O(log n).
